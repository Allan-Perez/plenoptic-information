"""
Created on Tue Aug 16 2021
@author: Allan Perez, School of Physics and Astronomy, University of Glasgow,
2480326p@student.gla.ac.uk

This program aims to investigate the DPDW in a different manner from Linquidst. The inital
idea is to take np.grad accross space at each time stamp, and then take the normal to this
gradient as the "incidence angle".
"""
from diffuse_imaging_FT import DiffusionSim, BeamGenerator
import numpy as np, matplotlib.pyplot as plt, os
from utils import generate_parameters


def grad_visualize(grid2D, i):
    grad1, grad2 = np.gradient(grid2D)
    plt.imshow(grad1)
    plt.title('Gradient axis 0')
    plt.savefig(f'img/gradient/axis_0/{i}.png')
    plt.imshow(grad2)
    plt.title('Gradient axis 0')
    plt.savefig(f'img/gradient/axis_1/{i}.png')

if __name__=='__main__':
    # Create parameters
    params = generate_parameters()

    # Simulators
    diffSim = DiffusionSim(**params)
    bGen = BeamGenerator(**params)

    # Beam shape
    # Beam's note: It is supposed to be equidistant from the two sources. 
    # So in any case, the detector should be at [0,0]
    input_center = [0,0]        # beam center position (cm)
    input_width = 0.5           # beam width (cm, s.d.)
    beamInput = bGen.intensity_distribution(input_center,
                                                 input_width, 9)
    #bGen.visualize(beamInput2)

    # Mask loading - absorber
    maskp = np.genfromtxt('test_masks/plus.txt')
    maskp = np.divide(maskp,255)
    mask = np.ones([diffSim.FoVNumBins, diffSim.FoVNumBins])#mask.shape)
    mask[1:,1:] = maskp
    mask = np.pad(mask,(params["padSize"],)*2,'constant',constant_values=1)

    # Perform simulation
    pl1 = params["propagationLen1"]
    pl2 = params["propagationLen2"]
    outInterface, middleInterface = diffSim.forward_model(beamInput,mask,pl1,pl2)
    """
    Z=outInterface.argmax(axis=-1)

    print(f"First timebin max: {Z.min()}")
    X = np.arange(outInterface.shape[0])
    Y = np.arange(outInterface.shape[1])
    X,Y = np.meshgrid(X, Y)
    fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
    surf = ax.plot_surface(X,Y,Z, linewidth=0, antialiased=False)
    ax.set_zlabel('Time Bin of max(phi)', rotation = 0)
    ax.set_ylabel('Spatial Y (Column bin)', rotation = 0)
    ax.set_xlabel('Spatial X (Row bin)', rotation = 0)
    plt.show()
    """

    l = outInterface.shape[-1]
    for i in range(l):
        grad_visualize(outInterface[:,:,i], i)
        print(f'Iteration {i}/{l}')
